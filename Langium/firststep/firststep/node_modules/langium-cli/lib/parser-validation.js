"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateParser = void 0;
const langium_1 = require("langium");
const package_1 = require("./package");
function validateParser(grammar, config, grammarConfigMap, documents) {
    var _a;
    const parserConfig = Object.assign(Object.assign(Object.assign({}, config.chevrotainParserConfig), (_a = grammarConfigMap.get(grammar)) === null || _a === void 0 ? void 0 : _a.chevrotainParserConfig), { skipValidations: false });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const unavailable = () => ({});
    const generatedSharedModule = {
        AstReflection: unavailable,
    };
    const generatedModule = {
        Grammar: () => grammar,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        LanguageMetaData: () => grammarConfigMap.get(grammar),
        parser: {
            ParserConfig: () => parserConfig
        }
    };
    const shared = (0, langium_1.inject)((0, langium_1.createDefaultSharedModule)(), generatedSharedModule);
    const services = (0, langium_1.inject)((0, langium_1.createDefaultModule)({ shared }), generatedModule);
    let parser;
    try {
        parser = (0, langium_1.prepareLangiumParser)(services);
        // The finalization step invokes parser validation, which can lead to thrown errors
        parser.finalize();
        return undefined;
    }
    catch (err) {
        if (parser && parser.definitionErrors.length > 0) {
            // Construct a message with tracing information
            let message = 'Parser definition errors detected:';
            for (const defError of parser.definitionErrors) {
                message += '\n-------------------------------\n';
                if (defError.ruleName) {
                    const rule = findRule(defError.ruleName, grammar, documents);
                    if (rule && rule.$cstNode) {
                        const filePath = (0, package_1.getFilePath)((0, langium_1.getDocument)(rule).uri.fsPath, config);
                        const line = rule.$cstNode.range.start.line + 1;
                        message += `${filePath}:${line} - `;
                    }
                }
                message += defError.message;
            }
            return new Error(message);
        }
        if (err instanceof Error) {
            return err;
        }
        throw err;
    }
}
exports.validateParser = validateParser;
function findRule(name, grammar, documents) {
    for (const rule of grammar.rules) {
        if (rule.name === name && (0, langium_1.isParserRule)(rule)) {
            return rule;
        }
    }
    for (const document of documents.all) {
        const ast = document.parseResult.value;
        if ((0, langium_1.isGrammar)(ast)) {
            for (const rule of ast.rules) {
                if (rule.name === name && (0, langium_1.isParserRule)(rule)) {
                    return rule;
                }
            }
        }
    }
    return undefined;
}
//# sourceMappingURL=parser-validation.js.map