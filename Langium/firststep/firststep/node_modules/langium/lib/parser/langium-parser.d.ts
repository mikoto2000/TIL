/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
import { DSLMethodOpts, ILexingError, IMultiModeLexerDefinition, IOrAlt, IParserErrorMessageProvider, IRecognitionException, IToken, TokenType, TokenTypeDictionary, TokenVocabulary } from 'chevrotain';
import { AbstractElement, Action } from '../grammar/generated/ast';
import { LangiumServices } from '../services';
import { AstNode } from '../syntax-tree';
export declare type ParseResult<T = AstNode> = {
    value: T;
    parserErrors: IRecognitionException[];
    lexerErrors: ILexingError[];
};
export declare const DatatypeSymbol: unique symbol;
declare type RuleResult = () => any;
declare type Args = Record<string, boolean>;
declare type RuleImpl = (args: Args) => any;
declare type Alternatives = Array<IOrAlt<any>>;
export declare class LangiumParser {
    private readonly linker;
    private readonly converter;
    private readonly lexer;
    private readonly nodeBuilder;
    private readonly wrapper;
    private stack;
    private mainRule;
    private assignmentMap;
    private get current();
    constructor(services: LangiumServices, tokens: TokenVocabulary);
    MAIN_RULE(name: string, type: string | symbol | undefined, implementation: RuleImpl): RuleResult;
    DEFINE_RULE(name: string, type: string | symbol | undefined, implementation: RuleImpl): RuleResult;
    parse<T extends AstNode = AstNode>(input: string): ParseResult<T>;
    private addHiddenTokens;
    private addHiddenToken;
    private startImplementation;
    alternatives(idx: number, choices: Alternatives): void;
    optional(idx: number, callback: DSLMethodOpts<unknown>): void;
    many(idx: number, callback: DSLMethodOpts<unknown>): void;
    atLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void;
    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;
    unassignedSubrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): void;
    subrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): any;
    action($type: string, action: Action): void;
    /**
     * Initializes array fields of the current object. Array fields are not allowed to be undefined.
     * Therefore, all array fields are initialized with an empty array.
     * @param initialArrayProperties The grammar access element that belongs to the current rule
     */
    initializeElement(initialArrayProperties: string[]): void;
    construct(pop?: boolean): unknown;
    private getAssignment;
    private assign;
    private assignWithoutOverride;
    finalize(): void;
    get definitionErrors(): IParserDefinitionError[];
}
export interface IParserDefinitionError {
    message: string;
    type: number;
    ruleName?: string;
}
export declare class LangiumParserErrorMessageProvider implements IParserErrorMessageProvider {
    buildMismatchTokenMessage({ expected, actual }: {
        expected: TokenType;
        actual: IToken;
        previous: IToken;
        ruleName: string;
    }): string;
    buildNotAllInputParsedMessage({ firstRedundant }: {
        firstRedundant: IToken;
        ruleName: string;
    }): string;
    buildNoViableAltMessage(options: {
        expectedPathsPerAlt: TokenType[][][];
        actual: IToken[];
        previous: IToken;
        customUserDescription: string;
        ruleName: string;
    }): string;
    buildEarlyExitMessage(options: {
        expectedIterationPaths: TokenType[][];
        actual: IToken[];
        previous: IToken;
        customUserDescription: string;
        ruleName: string;
    }): string;
}
/**
 * Returns a check whether the given TokenVocabulary is TokenType array
 */
export declare function isTokenTypeArray(tokenVocabulary: TokenVocabulary): tokenVocabulary is TokenType[];
/**
 * Returns a check whether the given TokenVocabulary is IMultiModeLexerDefinition
 */
export declare function isIMultiModeLexerDefinition(tokenVocabulary: TokenVocabulary): tokenVocabulary is IMultiModeLexerDefinition;
/**
 * Returns a check whether the given TokenVocabulary is TokenTypeDictionary
 */
export declare function isTokenTypeDictionary(tokenVocabulary: TokenVocabulary): tokenVocabulary is TokenTypeDictionary;
export {};
//# sourceMappingURL=langium-parser.d.ts.map