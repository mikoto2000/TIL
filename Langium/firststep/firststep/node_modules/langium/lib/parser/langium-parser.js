"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTokenTypeDictionary = exports.isIMultiModeLexerDefinition = exports.isTokenTypeArray = exports.LangiumParserErrorMessageProvider = exports.LangiumParser = exports.DatatypeSymbol = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const chevrotain_1 = require("chevrotain");
const ast_1 = require("../grammar/generated/ast");
const ast_util_1 = require("../utils/ast-util");
const cst_util_1 = require("../utils/cst-util");
const cst_node_builder_1 = require("./cst-node-builder");
exports.DatatypeSymbol = Symbol('Datatype');
function isDataTypeNode(node) {
    return node.$type === exports.DatatypeSymbol;
}
class LangiumParser {
    constructor(services, tokens) {
        this.nodeBuilder = new cst_node_builder_1.CstNodeBuilder();
        this.stack = [];
        this.assignmentMap = new Map();
        this.wrapper = new ChevrotainWrapper(tokens, services.parser.ParserConfig);
        this.linker = services.references.Linker;
        this.converter = services.parser.ValueConverter;
        this.lexer = new chevrotain_1.Lexer(isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens);
    }
    get current() {
        return this.stack[this.stack.length - 1];
    }
    MAIN_RULE(name, type, implementation) {
        return this.mainRule = this.DEFINE_RULE(name, type, implementation);
    }
    DEFINE_RULE(name, type, implementation) {
        return this.wrapper.DEFINE_RULE(name, this.startImplementation(type, implementation).bind(this));
    }
    parse(input) {
        this.nodeBuilder.buildRootNode(input);
        const lexerResult = this.lexer.tokenize(input);
        this.wrapper.input = lexerResult.tokens;
        const result = this.mainRule.call(this.wrapper);
        this.addHiddenTokens(result.$cstNode, lexerResult.groups.hidden);
        return {
            value: result,
            lexerErrors: lexerResult.errors,
            parserErrors: this.wrapper.errors
        };
    }
    addHiddenTokens(node, tokens) {
        if (tokens) {
            for (const token of tokens) {
                const hiddenNode = new cst_node_builder_1.LeafCstNodeImpl(token.startOffset, token.image.length, (0, cst_util_1.tokenToRange)(token), token.tokenType, true);
                hiddenNode.root = node;
                this.addHiddenToken(node, hiddenNode);
            }
        }
    }
    addHiddenToken(node, token) {
        const { offset, end } = node;
        const { offset: tokenStart, end: tokenEnd } = token;
        if (offset >= tokenEnd) {
            node.children.unshift(token);
        }
        else if (end <= tokenStart) {
            node.children.push(token);
        }
        else {
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const childEnd = child.end;
                if (child instanceof cst_node_builder_1.CompositeCstNodeImpl && tokenEnd < childEnd) {
                    this.addHiddenToken(child, token);
                    return;
                }
                else if (tokenEnd <= child.offset) {
                    node.children.splice(i, 0, token);
                    return;
                }
            }
        }
    }
    startImplementation($type, implementation) {
        return (args) => {
            if (!this.wrapper.IS_RECORDING) {
                const node = { $type };
                this.stack.push(node);
                if ($type === exports.DatatypeSymbol) {
                    node.value = '';
                }
            }
            let result;
            try {
                result = implementation(args);
            }
            catch (err) {
                result = undefined;
            }
            if (!this.wrapper.IS_RECORDING && result === undefined) {
                result = this.construct();
            }
            return result;
        };
    }
    alternatives(idx, choices) {
        this.wrapper.wrapOr(idx, choices);
    }
    optional(idx, callback) {
        this.wrapper.wrapOption(idx, callback);
    }
    many(idx, callback) {
        this.wrapper.wrapMany(idx, callback);
    }
    atLeastOne(idx, callback) {
        this.wrapper.wrapAtLeastOne(idx, callback);
    }
    consume(idx, tokenType, feature) {
        const token = this.wrapper.wrapConsume(idx, tokenType);
        if (!this.wrapper.IS_RECORDING) {
            const leafNode = this.nodeBuilder.buildLeafNode(token, feature);
            const { assignment, crossRef } = this.getAssignment(feature);
            const current = this.current;
            if (assignment) {
                let crossRefId;
                if (crossRef) {
                    crossRefId = `${current.$type}:${assignment.feature}`;
                }
                const convertedValue = (0, ast_1.isKeyword)(feature) ? token.image : this.converter.convert(token.image, leafNode);
                this.assign(assignment, convertedValue, leafNode, crossRefId);
            }
            else if (isDataTypeNode(current)) {
                let text = token.image;
                if (!(0, ast_1.isKeyword)(feature)) {
                    text = this.converter.convert(text, leafNode).toString();
                }
                current.value += text;
            }
        }
    }
    unassignedSubrule(idx, rule, feature, args) {
        const result = this.subrule(idx, rule, feature, args);
        if (!this.wrapper.IS_RECORDING) {
            const current = this.current;
            if (isDataTypeNode(current)) {
                current.value += result.toString();
            }
            else {
                const resultKind = result.$type;
                const object = this.assignWithoutOverride(result, current);
                if (resultKind) {
                    object.$type = resultKind;
                }
                const newItem = object;
                this.stack.pop();
                this.stack.push(newItem);
            }
        }
    }
    subrule(idx, rule, feature, args) {
        let cstNode;
        if (!this.wrapper.IS_RECORDING) {
            cstNode = this.nodeBuilder.buildCompositeNode(feature);
        }
        const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);
        if (!this.wrapper.IS_RECORDING) {
            const { assignment, crossRef } = this.getAssignment(feature);
            if (assignment && cstNode) {
                let crossRefId;
                if (crossRef) {
                    crossRefId = `${this.current.$type}:${assignment.feature}`;
                }
                this.assign(assignment, subruleResult, cstNode, crossRefId);
            }
        }
        return subruleResult;
    }
    action($type, action) {
        if (!this.wrapper.IS_RECORDING) {
            let last = this.current;
            // This branch is used for left recursive grammar rules.
            // Those don't call `construct` before another action.
            // Therefore, we need to call it here.
            if (!last.$cstNode && action.feature && action.operator) {
                last = this.construct(false);
                const feature = last.$cstNode.feature;
                this.nodeBuilder.buildCompositeNode(feature);
            }
            const newItem = { $type };
            this.stack.pop();
            this.stack.push(newItem);
            if (action.feature && action.operator) {
                this.assign(action, last, last.$cstNode);
            }
        }
    }
    /**
     * Initializes array fields of the current object. Array fields are not allowed to be undefined.
     * Therefore, all array fields are initialized with an empty array.
     * @param initialArrayProperties The grammar access element that belongs to the current rule
     */
    initializeElement(initialArrayProperties) {
        if (!this.wrapper.IS_RECORDING) {
            const item = this.current;
            for (const element of initialArrayProperties) {
                item[element] = [];
            }
        }
    }
    construct(pop = true) {
        if (this.wrapper.IS_RECORDING) {
            return undefined;
        }
        const obj = this.current;
        (0, ast_util_1.linkContentToContainer)(obj);
        this.nodeBuilder.construct(obj);
        if (pop) {
            this.stack.pop();
        }
        if (isDataTypeNode(obj)) {
            return this.converter.convert(obj.value, obj.$cstNode);
        }
        return obj;
    }
    getAssignment(feature) {
        if (!this.assignmentMap.has(feature)) {
            const assignment = (0, ast_util_1.getContainerOfType)(feature, ast_1.isAssignment);
            this.assignmentMap.set(feature, {
                assignment: assignment,
                crossRef: assignment ? (0, ast_1.isCrossReference)(assignment.terminal) : false
            });
        }
        return this.assignmentMap.get(feature);
    }
    assign(assignment, value, cstNode, crossRefId) {
        const obj = this.current;
        const feature = assignment.feature.replace(/\^/g, '');
        let item;
        if (crossRefId && typeof value === 'string') {
            item = this.linker.buildReference(obj, cstNode, crossRefId, value);
        }
        else {
            item = value;
        }
        switch (assignment.operator) {
            case '=': {
                obj[feature] = item;
                break;
            }
            case '?=': {
                obj[feature] = true;
                break;
            }
            case '+=': {
                if (!Array.isArray(obj[feature])) {
                    obj[feature] = [];
                }
                obj[feature].push(item);
            }
        }
    }
    assignWithoutOverride(target, source) {
        for (const [name, value] of Object.entries(source)) {
            if (target[name] === undefined) {
                target[name] = value;
            }
        }
        return target;
    }
    finalize() {
        this.wrapper.wrapSelfAnalysis();
    }
    get definitionErrors() {
        return this.wrapper.definitionErrors;
    }
}
exports.LangiumParser = LangiumParser;
class LangiumParserErrorMessageProvider {
    buildMismatchTokenMessage({ expected, actual }) {
        const expectedMsg = expected.LABEL
            ? '`' + expected.LABEL + '`'
            : expected.name.endsWith(':KW')
                ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'`
                : `token of type '${expected.name}'`;
        return `Expecting ${expectedMsg} but found \`${actual.image}\`.`;
    }
    buildNotAllInputParsedMessage({ firstRedundant }) {
        return `Expecting end of file but found \`${firstRedundant.image}\`.`;
    }
    buildNoViableAltMessage(options) {
        return chevrotain_1.defaultParserErrorProvider.buildNoViableAltMessage(options);
    }
    buildEarlyExitMessage(options) {
        return chevrotain_1.defaultParserErrorProvider.buildEarlyExitMessage(options);
    }
}
exports.LangiumParserErrorMessageProvider = LangiumParserErrorMessageProvider;
const defaultConfig = {
    recoveryEnabled: true,
    nodeLocationTracking: 'full',
    skipValidations: true,
    errorMessageProvider: new LangiumParserErrorMessageProvider()
};
/**
 * This class wraps the embedded actions parser of chevrotain and exposes protected methods.
 * This way, we can build the `LangiumParser` as a composition.
 */
class ChevrotainWrapper extends chevrotain_1.EmbeddedActionsParser {
    constructor(tokens, config) {
        super(tokens, Object.assign(Object.assign({}, defaultConfig), config));
    }
    get IS_RECORDING() {
        return this.RECORDING_PHASE;
    }
    DEFINE_RULE(name, impl) {
        return this.RULE(name, impl);
    }
    wrapSelfAnalysis() {
        this.performSelfAnalysis();
    }
    wrapConsume(idx, tokenType) {
        return this.consume(idx, tokenType);
    }
    wrapSubrule(idx, rule, args) {
        return this.subrule(idx, rule, {
            ARGS: [args]
        });
    }
    wrapOr(idx, choices) {
        this.or(idx, choices);
    }
    wrapOption(idx, callback) {
        this.option(idx, callback);
    }
    wrapMany(idx, callback) {
        this.many(idx, callback);
    }
    wrapAtLeastOne(idx, callback) {
        this.atLeastOne(idx, callback);
    }
}
/**
 * Returns a check whether the given TokenVocabulary is TokenType array
 */
function isTokenTypeArray(tokenVocabulary) {
    return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || 'name' in tokenVocabulary[0]);
}
exports.isTokenTypeArray = isTokenTypeArray;
/**
 * Returns a check whether the given TokenVocabulary is IMultiModeLexerDefinition
 */
function isIMultiModeLexerDefinition(tokenVocabulary) {
    return tokenVocabulary && 'modes' in tokenVocabulary && 'defaultMode' in tokenVocabulary;
}
exports.isIMultiModeLexerDefinition = isIMultiModeLexerDefinition;
/**
 * Returns a check whether the given TokenVocabulary is TokenTypeDictionary
 */
function isTokenTypeDictionary(tokenVocabulary) {
    return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);
}
exports.isTokenTypeDictionary = isTokenTypeDictionary;
//# sourceMappingURL=langium-parser.js.map