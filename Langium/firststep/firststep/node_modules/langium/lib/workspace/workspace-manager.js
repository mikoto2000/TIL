"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultWorkspaceManager = void 0;
const path_1 = __importDefault(require("path"));
const vscode_uri_1 = require("vscode-uri");
class DefaultWorkspaceManager {
    constructor(services) {
        this.serviceRegistry = services.ServiceRegistry;
        this.langiumDocuments = services.workspace.LangiumDocuments;
        this.documentBuilder = services.workspace.DocumentBuilder;
        this.fileSystemProvider = services.workspace.FileSystemProvider;
    }
    initializeWorkspace(folders) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileExtensions = this.serviceRegistry.all.flatMap(e => e.LanguageMetaData.fileExtensions);
            const documents = [];
            const collector = (document) => documents.push(document);
            yield Promise.all(folders.map(wf => this.getRootFolder(wf))
                .map((rf) => __awaiter(this, void 0, void 0, function* () { return this.traverseFolder(rf, fileExtensions, collector); })));
            yield this.loadAdditionalDocuments(folders, collector);
            yield this.documentBuilder.build(documents);
        });
    }
    /**
     * Load all additional documents that shall be visible in the context of the given workspace
     * folders and add them to the collector. This can be used to include built-in libraries of
     * your language, which can be either loaded from provided files or constructed in memory.
     */
    loadAdditionalDocuments(_folders, _collector) {
        return Promise.resolve();
    }
    /**
     * Determine the root folder of the source documents in the given workspace folder.
     * The default implementation returns the URI of the workspace folder, but you can override
     * this to return a subfolder like `src` instead.
     */
    getRootFolder(workspaceFolder) {
        return vscode_uri_1.URI.parse(workspaceFolder.uri);
    }
    /**
     * Traverse the file system folder identified by the given URI and its subfolders. All
     * contained files that match the file extensions are added to the collector.
     */
    traverseFolder(folderPath, fileExtensions, collector) {
        return __awaiter(this, void 0, void 0, function* () {
            const content = yield this.fileSystemProvider.readDirectory(folderPath);
            for (const entry of content) {
                if (this.includeEntry(entry, fileExtensions)) {
                    if (entry.isDirectory) {
                        yield this.traverseFolder(entry.uri, fileExtensions, collector);
                    }
                    else if (entry.isFile) {
                        const document = this.langiumDocuments.getOrCreateDocument(entry.uri);
                        collector(document);
                    }
                }
            }
        });
    }
    /**
     * Determine whether the given folder entry shall be included while indexing the workspace.
     */
    includeEntry(entry, fileExtensions) {
        const name = vscode_uri_1.Utils.basename(entry.uri);
        if (name.startsWith('.')) {
            return false;
        }
        if (entry.isDirectory) {
            return name !== 'node_modules' && name !== 'out';
        }
        else if (entry.isFile) {
            return fileExtensions.includes(path_1.default.extname(name));
        }
        return false;
    }
}
exports.DefaultWorkspaceManager = DefaultWorkspaceManager;
//# sourceMappingURL=workspace-manager.js.map