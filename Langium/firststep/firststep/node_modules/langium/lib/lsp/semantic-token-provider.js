"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractSemanticTokenProvider = exports.SemanticTokensBuilder = exports.DefaultSemanticTokenOptions = exports.AllSemanticTokenModifiers = exports.AllSemanticTokenTypes = void 0;
/* eslint-disable no-bitwise */
const vscode_languageserver_1 = require("vscode-languageserver");
const grammar_util_1 = require("../grammar/grammar-util");
const ast_util_1 = require("../utils/ast-util");
exports.AllSemanticTokenTypes = {
    [vscode_languageserver_1.SemanticTokenTypes.class]: 0,
    [vscode_languageserver_1.SemanticTokenTypes.comment]: 1,
    [vscode_languageserver_1.SemanticTokenTypes.enum]: 2,
    [vscode_languageserver_1.SemanticTokenTypes.enumMember]: 3,
    [vscode_languageserver_1.SemanticTokenTypes.event]: 4,
    [vscode_languageserver_1.SemanticTokenTypes.function]: 5,
    [vscode_languageserver_1.SemanticTokenTypes.interface]: 6,
    [vscode_languageserver_1.SemanticTokenTypes.keyword]: 7,
    [vscode_languageserver_1.SemanticTokenTypes.macro]: 8,
    [vscode_languageserver_1.SemanticTokenTypes.method]: 9,
    [vscode_languageserver_1.SemanticTokenTypes.modifier]: 10,
    [vscode_languageserver_1.SemanticTokenTypes.namespace]: 11,
    [vscode_languageserver_1.SemanticTokenTypes.number]: 12,
    [vscode_languageserver_1.SemanticTokenTypes.operator]: 13,
    [vscode_languageserver_1.SemanticTokenTypes.parameter]: 14,
    [vscode_languageserver_1.SemanticTokenTypes.property]: 15,
    [vscode_languageserver_1.SemanticTokenTypes.regexp]: 16,
    [vscode_languageserver_1.SemanticTokenTypes.string]: 17,
    [vscode_languageserver_1.SemanticTokenTypes.struct]: 18,
    [vscode_languageserver_1.SemanticTokenTypes.type]: 19,
    [vscode_languageserver_1.SemanticTokenTypes.typeParameter]: 20,
    [vscode_languageserver_1.SemanticTokenTypes.variable]: 21
};
exports.AllSemanticTokenModifiers = {
    [vscode_languageserver_1.SemanticTokenModifiers.abstract]: 1 << 0,
    [vscode_languageserver_1.SemanticTokenModifiers.async]: 1 << 1,
    [vscode_languageserver_1.SemanticTokenModifiers.declaration]: 1 << 2,
    [vscode_languageserver_1.SemanticTokenModifiers.defaultLibrary]: 1 << 3,
    [vscode_languageserver_1.SemanticTokenModifiers.definition]: 1 << 4,
    [vscode_languageserver_1.SemanticTokenModifiers.deprecated]: 1 << 5,
    [vscode_languageserver_1.SemanticTokenModifiers.documentation]: 1 << 6,
    [vscode_languageserver_1.SemanticTokenModifiers.modification]: 1 << 7,
    [vscode_languageserver_1.SemanticTokenModifiers.readonly]: 1 << 8,
    [vscode_languageserver_1.SemanticTokenModifiers.static]: 1 << 9
};
exports.DefaultSemanticTokenOptions = {
    legend: {
        tokenTypes: Object.keys(exports.AllSemanticTokenTypes),
        tokenModifiers: Object.keys(exports.AllSemanticTokenModifiers)
    },
    full: {
        delta: true
    },
    range: true
};
class SemanticTokensBuilder extends vscode_languageserver_1.SemanticTokensBuilder {
    constructor() {
        super(...arguments);
        this._tokens = [];
    }
    push(line, char, length, tokenType, tokenModifiers) {
        this._tokens.push({
            line,
            char,
            length,
            tokenType,
            tokenModifiers
        });
    }
    build() {
        this.applyTokens();
        return super.build();
    }
    buildEdits() {
        this.applyTokens();
        return super.buildEdits();
    }
    applyTokens() {
        for (const token of this._tokens.sort(this.compareTokens)) {
            super.push(token.line, token.char, token.length, token.tokenType, token.tokenModifiers);
        }
        this._tokens = [];
    }
    compareTokens(a, b) {
        if (a.line === b.line) {
            return a.char - b.char;
        }
        return a.line - b.line;
    }
}
exports.SemanticTokensBuilder = SemanticTokensBuilder;
/**
 * A basic super class for providing semantic token data.
 * Users of Langium should extend this class to create their own `SemanticTokenProvider`.
 *
 * The entry method for generating semantic tokens based on an `AstNode` is the `highlightElement` method.
 */
class AbstractSemanticTokenProvider {
    constructor() {
        this.tokenBuilder = new SemanticTokensBuilder();
        this.acceptor = options => {
            if ('line' in options) {
                this.highlightToken(options.line, options.char, options.length, options.type, options.modifier);
            }
            else if ('keyword' in options) {
                this.highlightKeyword(options.node, options.keyword, options.type, options.modifier);
            }
            else if ('feature' in options) {
                this.highlightFeature(options.node, options.feature, options.index, options.type, options.modifier);
            }
            else {
                this.highlightNode(options.node, options.type, options.modifier);
            }
        };
    }
    semanticHighlight(document, _params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        this.range = undefined;
        this.resetTokensBuilder();
        this.computeHighlighting(document, this.acceptor, cancelToken);
        return this.tokenBuilder.build();
    }
    semanticHighlightRange(document, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        this.range = params.range;
        this.resetTokensBuilder();
        this.computeHighlighting(document, this.acceptor, cancelToken);
        return this.tokenBuilder.build();
    }
    semanticHighlightDelta(document, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        this.range = undefined;
        this.tokenBuilder.previousResult(params.previousResultId);
        this.computeHighlighting(document, this.acceptor, cancelToken);
        return this.tokenBuilder.buildEdits();
    }
    resetTokensBuilder() {
        this.tokenBuilder.previousResult(Date.now().toString());
    }
    computeHighlighting(document, acceptor, cancelToken) {
        const root = document.parseResult.value;
        const treeIterator = (0, ast_util_1.streamAllContents)(root).iterator();
        let result;
        do {
            result = treeIterator.next();
            if (!result.done) {
                if (cancelToken.isCancellationRequested) {
                    break;
                }
                const node = result.value;
                const nodeRange = node.$cstNode.range;
                const comparedRange = this.compareRange(nodeRange);
                if (comparedRange === 1) {
                    break; // Every following element will not be in range, so end the loop
                }
                else if (comparedRange === -1) {
                    continue; // Current element is ending before range starts, skip to next element
                }
                if (this.highlightElement(node, acceptor) === 'prune') {
                    treeIterator.prune();
                }
            }
        } while (!result.done);
    }
    compareRange(range) {
        if (!this.range) {
            return 0;
        }
        const startLine = typeof range === 'number' ? range : range.start.line;
        const endLine = typeof range === 'number' ? range : range.end.line;
        if (endLine < this.range.start.line) {
            return -1;
        }
        else if (startLine > this.range.end.line) {
            return 1;
        }
        else {
            return 0;
        }
    }
    highlightToken(line, char, length, type, modifiers) {
        if (this.compareRange(line) !== 0) {
            return;
        }
        const intType = exports.AllSemanticTokenTypes[type];
        let totalModifier = 0;
        if (modifiers !== undefined) {
            if (typeof modifiers === 'string') {
                modifiers = [modifiers];
            }
            for (const modifier of modifiers) {
                const intModifier = exports.AllSemanticTokenModifiers[modifier];
                totalModifier |= intModifier;
            }
        }
        this.tokenBuilder.push(line, char, length, intType, totalModifier);
    }
    highlightFeature(node, feature, index, type, modifiers) {
        const featureNode = (0, grammar_util_1.findNodeForFeature)(node.$cstNode, feature, index);
        if (featureNode) {
            this.highlightNode(featureNode, type, modifiers);
        }
    }
    highlightKeyword(node, keyword, type, modifiers) {
        const keywordNode = (0, grammar_util_1.findKeywordNode)(node.$cstNode, keyword);
        if (keywordNode) {
            this.highlightNode(keywordNode, type, modifiers);
        }
    }
    highlightNode(node, type, modifiers) {
        const nodeRange = node.range;
        this.highlightToken(nodeRange.start.line, nodeRange.start.character, nodeRange.end.character - nodeRange.start.character, type, modifiers);
    }
}
exports.AbstractSemanticTokenProvider = AbstractSemanticTokenProvider;
//# sourceMappingURL=semantic-token-provider.js.map