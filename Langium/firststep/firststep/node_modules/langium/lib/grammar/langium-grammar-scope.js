"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangiumGrammarScopeComputation = exports.LangiumScopeProvider = void 0;
const scope_1 = require("../references/scope");
const ast_util_1 = require("../utils/ast-util");
const stream_1 = require("../utils/stream");
const ast_1 = require("./generated/ast");
const grammar_util_1 = require("./grammar-util");
class LangiumScopeProvider extends scope_1.DefaultScopeProvider {
    constructor(services) {
        super(services);
    }
    getScope(node, referenceId) {
        const referenceType = this.reflection.getReferenceType(referenceId);
        if (referenceType !== 'AbstractType')
            return super.getScope(node, referenceId);
        const scopes = [];
        const precomputed = (0, ast_util_1.getDocument)(node).precomputedScopes;
        const rootNode = (0, ast_util_1.extractRootNode)(node);
        if (precomputed && rootNode) {
            const allDescriptions = precomputed.get(rootNode);
            const parserRuleScopesArray = [];
            const scopesArray = [];
            if (allDescriptions.length > 0) {
                for (const description of allDescriptions) {
                    if (this.reflection.isSubtype(description.type, 'ParserRule')) {
                        parserRuleScopesArray.push(description);
                    }
                    else if (this.reflection.isSubtype(description.type, referenceType)) {
                        scopesArray.push(description);
                    }
                }
                scopes.push((0, stream_1.stream)(scopesArray.concat(parserRuleScopesArray.filter(parserRule => !scopesArray.some(e => e.name === parserRule.name)))));
            }
        }
        let result = this.getGlobalScope(referenceType);
        for (let i = scopes.length - 1; i >= 0; i--) {
            result = this.createScope(scopes[i], result);
        }
        return result;
    }
}
exports.LangiumScopeProvider = LangiumScopeProvider;
class LangiumGrammarScopeComputation extends scope_1.DefaultScopeComputation {
    constructor(services) {
        super(services);
        this.processTypeNode = (0, grammar_util_1.processTypeNodeWithNodeLocator)(services.index.AstNodeLocator);
        this.processActionNode = (0, grammar_util_1.processActionNodeWithNodeDescriptionProvider)(services.index.AstNodeDescriptionProvider);
    }
    processNode(node, document, scopes) {
        if ((0, ast_1.isReturnType)(node))
            return;
        this.processTypeNode(node, document, scopes);
        this.processActionNode(node, document, scopes);
        super.processNode(node, document, scopes);
    }
}
exports.LangiumGrammarScopeComputation = LangiumGrammarScopeComputation;
//# sourceMappingURL=langium-grammar-scope.js.map