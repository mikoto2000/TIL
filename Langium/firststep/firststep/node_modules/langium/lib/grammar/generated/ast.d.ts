/******************************************************************************
 * This file was generated by langium-cli 0.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
import { AstNode, AstReflection, Reference } from '../../syntax-tree';
export declare type AbstractRule = ParserRule | TerminalRule;
export declare const AbstractRule = "AbstractRule";
export declare function isAbstractRule(item: unknown): item is AbstractRule;
export declare type AbstractType = Action | Interface | ParserRule | Type;
export declare const AbstractType = "AbstractType";
export declare function isAbstractType(item: unknown): item is AbstractType;
export declare type Condition = Conjunction | Disjunction | LiteralCondition | Negation | ParameterReference;
export declare const Condition = "Condition";
export declare function isCondition(item: unknown): item is Condition;
export declare type FeatureName = string;
export declare type PrimitiveType = 'boolean' | 'date' | 'number' | 'string';
export interface AbstractElement extends AstNode {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    cardinality: '*' | '+' | '?';
}
export declare const AbstractElement = "AbstractElement";
export declare function isAbstractElement(item: unknown): item is AbstractElement;
export interface Action extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    feature: FeatureName;
    infer: boolean;
    operator: '+=' | '=';
    type: string;
}
export declare const Action = "Action";
export declare function isAction(item: unknown): item is Action;
export interface Alternatives extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    elements: Array<AbstractElement>;
}
export declare const Alternatives = "Alternatives";
export declare function isAlternatives(item: unknown): item is Alternatives;
export interface Assignment extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    feature: FeatureName;
    firstSetPredicated: boolean;
    operator: '+=' | '=' | '?=';
    predicated: boolean;
    terminal: AbstractElement;
}
export declare const Assignment = "Assignment";
export declare function isAssignment(item: unknown): item is Assignment;
export interface AtomType extends AstNode {
    readonly $container: Type | TypeAttribute;
    isArray: boolean;
    isRef: boolean;
    keywordType: Keyword;
    primitiveType: PrimitiveType;
    refType: Reference<AbstractType>;
}
export declare const AtomType = "AtomType";
export declare function isAtomType(item: unknown): item is AtomType;
export interface CharacterRange extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    left: Keyword;
    right: Keyword;
}
export declare const CharacterRange = "CharacterRange";
export declare function isCharacterRange(item: unknown): item is CharacterRange;
export interface Conjunction extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    left: Condition;
    right: Condition;
}
export declare const Conjunction = "Conjunction";
export declare function isConjunction(item: unknown): item is Conjunction;
export interface CrossReference extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    deprecatedSyntax: boolean;
    terminal: AbstractElement;
    type: Reference<AbstractType>;
}
export declare const CrossReference = "CrossReference";
export declare function isCrossReference(item: unknown): item is CrossReference;
export interface Disjunction extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    left: Condition;
    right: Condition;
}
export declare const Disjunction = "Disjunction";
export declare function isDisjunction(item: unknown): item is Disjunction;
export interface Grammar extends AstNode {
    definesHiddenTokens: boolean;
    hiddenTokens: Array<Reference<AbstractRule>>;
    imports: Array<GrammarImport>;
    interfaces: Array<Interface>;
    isDeclared: boolean;
    name: string;
    rules: Array<AbstractRule>;
    types: Array<Type>;
    usedGrammars: Array<Reference<Grammar>>;
}
export declare const Grammar = "Grammar";
export declare function isGrammar(item: unknown): item is Grammar;
export interface GrammarImport extends AstNode {
    readonly $container: Grammar;
    path: string;
}
export declare const GrammarImport = "GrammarImport";
export declare function isGrammarImport(item: unknown): item is GrammarImport;
export interface Group extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    elements: Array<AbstractElement>;
    firstSetPredicated: boolean;
    guardCondition: Condition;
    predicated: boolean;
}
export declare const Group = "Group";
export declare function isGroup(item: unknown): item is Group;
export interface Interface extends AstNode {
    readonly $container: Grammar;
    attributes: Array<TypeAttribute>;
    name: string;
    superTypes: Array<Reference<AbstractType>>;
}
export declare const Interface = "Interface";
export declare function isInterface(item: unknown): item is Interface;
export interface Keyword extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    firstSetPredicated: boolean;
    predicated: boolean;
    value: string;
}
export declare const Keyword = "Keyword";
export declare function isKeyword(item: unknown): item is Keyword;
export interface LiteralCondition extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    true: boolean;
}
export declare const LiteralCondition = "LiteralCondition";
export declare function isLiteralCondition(item: unknown): item is LiteralCondition;
export interface NamedArgument extends AstNode {
    readonly $container: RuleCall;
    calledByName: boolean;
    parameter?: Reference<Parameter>;
    value: Condition;
}
export declare const NamedArgument = "NamedArgument";
export declare function isNamedArgument(item: unknown): item is NamedArgument;
export interface NegatedToken extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    terminal: AbstractElement;
}
export declare const NegatedToken = "NegatedToken";
export declare function isNegatedToken(item: unknown): item is NegatedToken;
export interface Negation extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    value: Condition;
}
export declare const Negation = "Negation";
export declare function isNegation(item: unknown): item is Negation;
export interface Parameter extends AstNode {
    readonly $container: ParserRule;
    name: string;
}
export declare const Parameter = "Parameter";
export declare function isParameter(item: unknown): item is Parameter;
export interface ParameterReference extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    parameter: Reference<Parameter>;
}
export declare const ParameterReference = "ParameterReference";
export declare function isParameterReference(item: unknown): item is ParameterReference;
export interface ParserRule extends AstNode {
    readonly $container: Grammar;
    alternatives: AbstractElement;
    definesHiddenTokens: boolean;
    entry: boolean;
    fragment: boolean;
    hiddenTokens: Array<Reference<AbstractRule>>;
    infers: boolean;
    name: string;
    parameters: Array<Parameter>;
    type: ReturnType;
    wildcard: boolean;
}
export declare const ParserRule = "ParserRule";
export declare function isParserRule(item: unknown): item is ParserRule;
export interface RegexToken extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    regex: string;
}
export declare const RegexToken = "RegexToken";
export declare function isRegexToken(item: unknown): item is RegexToken;
export interface ReturnType extends AstNode {
    readonly $container: ParserRule | TerminalRule;
    name: PrimitiveType | string;
}
export declare const ReturnType = "ReturnType";
export declare function isReturnType(item: unknown): item is ReturnType;
export interface RuleCall extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    arguments: Array<NamedArgument>;
    firstSetPredicated: boolean;
    predicated: boolean;
    rule: Reference<AbstractRule>;
}
export declare const RuleCall = "RuleCall";
export declare function isRuleCall(item: unknown): item is RuleCall;
export interface TerminalAlternatives extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    elements: Array<AbstractElement>;
}
export declare const TerminalAlternatives = "TerminalAlternatives";
export declare function isTerminalAlternatives(item: unknown): item is TerminalAlternatives;
export interface TerminalGroup extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    elements: Array<AbstractElement>;
}
export declare const TerminalGroup = "TerminalGroup";
export declare function isTerminalGroup(item: unknown): item is TerminalGroup;
export interface TerminalRule extends AstNode {
    readonly $container: Grammar;
    fragment: boolean;
    hidden: boolean;
    name: string;
    terminal: AbstractElement;
    type: ReturnType;
}
export declare const TerminalRule = "TerminalRule";
export declare function isTerminalRule(item: unknown): item is TerminalRule;
export interface TerminalRuleCall extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    rule: Reference<TerminalRule>;
}
export declare const TerminalRuleCall = "TerminalRuleCall";
export declare function isTerminalRuleCall(item: unknown): item is TerminalRuleCall;
export interface Type extends AstNode {
    readonly $container: Grammar;
    name: string;
    typeAlternatives: Array<AtomType>;
}
export declare const Type = "Type";
export declare function isType(item: unknown): item is Type;
export interface TypeAttribute extends AstNode {
    readonly $container: Interface;
    isOptional: boolean;
    name: string;
    typeAlternatives: Array<AtomType>;
}
export declare const TypeAttribute = "TypeAttribute";
export declare function isTypeAttribute(item: unknown): item is TypeAttribute;
export interface UnorderedGroup extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    elements: Array<AbstractElement>;
}
export declare const UnorderedGroup = "UnorderedGroup";
export declare function isUnorderedGroup(item: unknown): item is UnorderedGroup;
export interface UntilToken extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    terminal: AbstractElement;
}
export declare const UntilToken = "UntilToken";
export declare function isUntilToken(item: unknown): item is UntilToken;
export interface Wildcard extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
}
export declare const Wildcard = "Wildcard";
export declare function isWildcard(item: unknown): item is Wildcard;
export declare type LangiumGrammarAstType = 'AbstractElement' | 'AbstractRule' | 'AbstractType' | 'Action' | 'Alternatives' | 'Assignment' | 'AtomType' | 'CharacterRange' | 'Condition' | 'Conjunction' | 'CrossReference' | 'Disjunction' | 'Grammar' | 'GrammarImport' | 'Group' | 'Interface' | 'Keyword' | 'LiteralCondition' | 'NamedArgument' | 'NegatedToken' | 'Negation' | 'Parameter' | 'ParameterReference' | 'ParserRule' | 'RegexToken' | 'ReturnType' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRule' | 'TerminalRuleCall' | 'Type' | 'TypeAttribute' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';
export declare type LangiumGrammarAstReference = 'AtomType:refType' | 'CrossReference:type' | 'Grammar:hiddenTokens' | 'Grammar:usedGrammars' | 'Interface:superTypes' | 'NamedArgument:parameter' | 'ParameterReference:parameter' | 'ParserRule:hiddenTokens' | 'RuleCall:rule' | 'TerminalRuleCall:rule';
export declare class LangiumGrammarAstReflection implements AstReflection {
    getAllTypes(): string[];
    isInstance(node: unknown, type: string): boolean;
    isSubtype(subtype: string, supertype: string): boolean;
    getReferenceType(referenceId: LangiumGrammarAstReference): string;
}
export declare const reflection: LangiumGrammarAstReflection;
//# sourceMappingURL=ast.d.ts.map