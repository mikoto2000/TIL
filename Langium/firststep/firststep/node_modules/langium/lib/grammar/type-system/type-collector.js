"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectAst = void 0;
const stream_1 = require("../../utils/stream");
const inferred_types_1 = require("./inferred-types");
const declared_types_1 = require("./declared-types");
const types_util_1 = require("./types-util");
/**
 * Collects all types for the generated AST. The types collector entry point.
 * @param documents Documents to resolve imports that were used in the given grammars.
 * @param grammars Grammars for which it's necessary to build an AST.
 */
function collectAst(documents, grammars) {
    const astResources = (0, types_util_1.collectAllAstResources)(grammars, documents);
    const inferred = (0, inferred_types_1.collectInferredTypes)(Array.from(astResources.parserRules), Array.from(astResources.datatypeRules));
    const declared = (0, declared_types_1.collectDeclaredTypes)(Array.from(astResources.interfaces), Array.from(astResources.types), inferred);
    const interfaces = inferred.interfaces.concat(declared.interfaces);
    const types = inferred.types.concat(declared.types);
    sortInterfaces(interfaces);
    types.sort((a, b) => a.name.localeCompare(b.name));
    return {
        interfaces: (0, stream_1.stream)(interfaces).distinct(e => e.name).toArray(),
        types: (0, stream_1.stream)(types).distinct(e => e.name).toArray(),
    };
}
exports.collectAst = collectAst;
/**
 * Performs topological sorting on the generated interfaces.
 * @param interfaces The interfaces to sort topologically.
 * @returns A topologically sorted set of interfaces.
 */
function sortInterfaces(interfaces) {
    const nodes = interfaces
        .sort((a, b) => a.name.localeCompare(b.name))
        .map(e => ({ value: e, nodes: [] }));
    for (const node of nodes) {
        node.nodes = nodes.filter(e => node.value.superTypes.includes(e.value.name));
    }
    const l = [];
    const s = nodes.filter(e => e.nodes.length === 0);
    while (s.length > 0) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const n = s.shift();
        if (!l.includes(n)) {
            l.push(n);
            nodes
                .filter(e => e.nodes.includes(n))
                .forEach(m => s.push(m));
        }
    }
    return l.map(e => e.value);
}
//# sourceMappingURL=type-collector.js.map