"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectAllInterfaces = exports.collectValidationResources = exports.applyErrorToAssignment = exports.validateTypesConsistency = void 0;
const grammar_util_1 = require("../grammar-util");
const collections_1 = require("../../utils/collections");
const declared_types_1 = require("./declared-types");
const inferred_types_1 = require("./inferred-types");
const types_util_1 = require("./types-util");
const stream_1 = require("../../utils/stream");
const ast_util_1 = require("../../utils/ast-util");
function validateTypesConsistency(grammar, accept) {
    function applyErrorToRuleNodes(nodes, typeName) {
        return (errorMessage) => {
            nodes.forEach(node => accept('error', errorMessage + ` in inferred type '${typeName}'.`, { node: (node === null || node === void 0 ? void 0 : node.type) ? node.type : node, property: 'name' }));
        };
    }
    const validationResources = collectValidationResources(grammar);
    for (const [typeName, typeInfo] of validationResources.entries()) {
        if (!isInferredAndDeclared(typeInfo))
            continue;
        const errorToRuleNodes = applyErrorToRuleNodes(typeInfo.nodes, typeName);
        const errorToAssignment = applyErrorToAssignment(typeInfo.nodes, accept);
        if (isType(typeInfo.inferred) && isType(typeInfo.declared)) {
            checkAlternativesConsistency(typeInfo.inferred.alternatives, typeInfo.declared.alternatives, errorToRuleNodes);
        }
        else if (isInterface(typeInfo.inferred) && isInterface(typeInfo.declared)) {
            checkPropertiesConsistency(typeInfo.inferred.properties, typeInfo.declared.properties, errorToRuleNodes, errorToAssignment);
            checkSuperTypesConsistency(typeInfo.inferred.superTypes, typeInfo.declared.superTypes, errorToRuleNodes);
        }
        else {
            const specificError = `Inferred and declared versions of type ${typeName} have to be types or interfaces both.`;
            typeInfo.nodes.forEach(node => accept('error', specificError, { node: (node === null || node === void 0 ? void 0 : node.type) ? node.type : node, property: 'name' }));
            accept('error', specificError, { node: typeInfo.node, property: 'name' });
        }
    }
}
exports.validateTypesConsistency = validateTypesConsistency;
function applyErrorToAssignment(nodes, accept) {
    const assignmentNodes = nodes.flatMap(node => (0, ast_util_1.extractAssignments)(node.alternatives));
    return (propertyName, errorMessage) => {
        const node = assignmentNodes.find(assignment => assignment.feature === propertyName);
        if (node) {
            accept('error', errorMessage, { node, property: 'feature' });
        }
    };
}
exports.applyErrorToAssignment = applyErrorToAssignment;
function isType(type) {
    return type && 'alternatives' in type;
}
function isInterface(type) {
    return type && 'properties' in type;
}
function isInferredAndDeclared(type) {
    return type && 'inferred' in type && 'declared' in type;
}
function collectValidationResources(grammar) {
    const astResources = (0, types_util_1.collectAllAstResources)([grammar]);
    const inferred = (0, inferred_types_1.collectInferredTypes)(Array.from(astResources.parserRules), Array.from(astResources.datatypeRules));
    const declared = (0, declared_types_1.collectDeclaredTypes)(Array.from(astResources.interfaces), Array.from(astResources.types), inferred);
    const typeNameToRules = getTypeNameToRules(astResources);
    const inferredInfo = mergeTypesAndInterfaces(inferred)
        .reduce((acc, type) => acc.set(type.name, { inferred: type, nodes: typeNameToRules.get(type.name) }), new Map());
    const allTypesInfo = mergeTypesAndInterfaces(declared)
        .reduce((acc, type) => {
        var _a;
        const node = (_a = (0, stream_1.stream)(astResources.types).find(e => e.name === type.name)) !== null && _a !== void 0 ? _a : (0, stream_1.stream)(astResources.interfaces).find(e => e.name === type.name);
        if (node) {
            const inferred = inferredInfo.get(type.name);
            acc.set(type.name, inferred ? Object.assign(Object.assign({}, inferred), { declared: type, node }) : { declared: type, node });
        }
        return acc;
    }, new Map());
    return allTypesInfo;
}
exports.collectValidationResources = collectValidationResources;
function getTypeNameToRules(astResources) {
    return (0, stream_1.stream)(astResources.parserRules)
        .concat(astResources.datatypeRules)
        .reduce((acc, rule) => acc.add((0, grammar_util_1.getRuleType)(rule), rule), new collections_1.MultiMap());
}
function mergeTypesAndInterfaces(astTypes) {
    return astTypes.interfaces.concat(astTypes.types);
}
const arrRefError = (found, expected) => found.array && !expected.array && found.reference && !expected.reference ? 'can\'t be an array and a reference' :
    !found.array && expected.array && !found.reference && expected.reference ? 'has to be an array and a reference' :
        found.array && !expected.array ? 'can\'t be an array' :
            !found.array && expected.array ? 'has to be an array' :
                found.reference && !expected.reference ? 'can\'t be a reference' :
                    !found.reference && expected.reference ? 'has to be a reference' : '';
function checkAlternativesConsistencyHelper(found, expected) {
    const stringToPropertyTypeList = (propertyTypeList) => propertyTypeList.reduce((acc, e) => acc.set((0, types_util_1.distictAndSorted)(e.types).join(' | '), e), new Map());
    const stringToFound = stringToPropertyTypeList(found);
    const stringToExpected = stringToPropertyTypeList(expected);
    const errorsInfo = [];
    // detects extra type alternatives & check matched ones on consistency by 'array' and 'reference'
    for (const [typeString, foundPropertyType] of (0, stream_1.stream)(stringToFound)) {
        const expectedPropertyType = stringToExpected.get(typeString);
        if (!expectedPropertyType) {
            errorsInfo.push({ typeString, errorMessage: 'is not expected' });
        }
        else if (expectedPropertyType.array !== foundPropertyType.array || expectedPropertyType.reference !== foundPropertyType.reference) {
            errorsInfo.push({ typeString, errorMessage: arrRefError(foundPropertyType, expectedPropertyType) });
        }
    }
    return errorsInfo;
}
function checkAlternativesConsistency(inferred, declared, errorToRuleNodes) {
    const errorsInfo = checkAlternativesConsistencyHelper(inferred, declared);
    for (const errorInfo of errorsInfo) {
        errorToRuleNodes(`A type '${errorInfo.typeString}' ${errorInfo.errorMessage}`);
    }
}
function checkPropertiesConsistency(inferred, declared, errorToRuleNodes, errorToAssignment) {
    const baseError = (propertyName, foundType, expectedType) => `The assigned type '${foundType}' is not compatible with the declared property '${propertyName}' of type '${expectedType}'.`;
    const checkOptional = (found, expected) => !(found.typeAlternatives.length === 1 && found.typeAlternatives[0].array ||
        expected.typeAlternatives.length === 1 && expected.typeAlternatives[0].array);
    // detects extra properties & check matched ones on consistency by 'opional'
    for (const foundProperty of inferred) {
        const expectedProperty = declared.find(e => foundProperty.name === e.name);
        if (expectedProperty) {
            const foundStringType = (0, types_util_1.propertyTypeArrayToString)(foundProperty.typeAlternatives);
            const expectedStringType = (0, types_util_1.propertyTypeArrayToString)(expectedProperty.typeAlternatives);
            if (foundStringType !== expectedStringType) {
                let resultError = baseError(foundProperty.name, foundStringType, expectedStringType);
                for (const errorInfo of checkAlternativesConsistencyHelper(foundProperty.typeAlternatives, expectedProperty.typeAlternatives)) {
                    resultError = resultError + ` '${errorInfo.typeString}' ${errorInfo.errorMessage};`;
                }
                resultError = resultError.replace(/;$/, '.');
                errorToAssignment(foundProperty.name, resultError);
            }
            if (checkOptional(foundProperty, expectedProperty) && !expectedProperty.optional && foundProperty.optional) {
                errorToAssignment(foundProperty.name, `A property '${foundProperty.name}' can't be optional.`);
            }
        }
        else {
            errorToAssignment(foundProperty.name, `A property '${foundProperty.name}' is not expected.`);
        }
    }
    // detects lack of properties
    for (const foundProperty of declared) {
        const expectedProperty = inferred.find(e => foundProperty.name === e.name);
        if (!expectedProperty) {
            errorToRuleNodes(`A property '${foundProperty.name}' is expected`);
        }
    }
}
function checkSuperTypesConsistency(inferred, declared, errorToRuleNodes) {
    const specificError = (superType, isExtra) => `A super type '${superType}' is ${isExtra ? 'not ' : ''}expected`;
    inferred
        .filter(e => !declared.includes(e))
        .forEach(extraSuperType => errorToRuleNodes(specificError(extraSuperType, true)));
    declared
        .filter(e => !inferred.includes(e))
        .forEach(lackSuperType => errorToRuleNodes(specificError(lackSuperType, false)));
}
// use only after type consistancy validation
function collectAllInterfaces(grammar) {
    const astResources = (0, types_util_1.collectAllAstResources)([grammar]);
    const inferred = (0, inferred_types_1.collectInferredTypes)(Array.from(astResources.parserRules), Array.from(astResources.datatypeRules));
    const declared = (0, declared_types_1.collectDeclaredTypes)(Array.from(astResources.interfaces), Array.from(astResources.types), inferred);
    const typeNameToRules = getTypeNameToRules(astResources);
    const inferredInterfaces = inferred.interfaces
        .reduce((acc, type) => acc.set(type.name, { type, node: typeNameToRules.get(type.name) }), new Map());
    return declared.interfaces
        .reduce((acc, type) => {
        if (!acc.has(type.name)) {
            const node = (0, stream_1.stream)(astResources.interfaces).find(e => e.name === type.name);
            if (node)
                acc.set(type.name, { type, node });
        }
        return acc;
    }, inferredInterfaces);
}
exports.collectAllInterfaces = collectAllInterfaces;
//# sourceMappingURL=type-validator.js.map