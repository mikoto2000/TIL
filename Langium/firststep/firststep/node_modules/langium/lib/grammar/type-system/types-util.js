"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.typePropertyToString = exports.distictAndSorted = exports.propertyTypeArrayToString = exports.collectAllAstResources = exports.InterfaceType = exports.TypeType = void 0;
const generator_node_1 = require("../../generator/generator-node");
const node_processor_1 = require("../../generator/node-processor");
const ast_1 = require("../generated/ast");
const grammar_util_1 = require("../grammar-util");
const ast_util_1 = require("../../utils/ast-util");
class TypeType {
    constructor(name, alternatives, options) {
        var _a;
        this.superTypes = [];
        this.name = name;
        this.alternatives = alternatives;
        this.reflection = (_a = options === null || options === void 0 ? void 0 : options.reflection) !== null && _a !== void 0 ? _a : false;
    }
    toString() {
        const typeNode = new generator_node_1.CompositeGeneratorNode();
        typeNode.contents.push(`export type ${this.name} = ${propertyTypeArrayToString(this.alternatives)};`, generator_node_1.NL);
        if (this.reflection)
            pushReflectionInfo(this.name, typeNode);
        return (0, node_processor_1.processGeneratorNode)(typeNode);
    }
}
exports.TypeType = TypeType;
class InterfaceType {
    constructor(name, superTypes, properties) {
        this.subTypes = [];
        this.containerTypes = [];
        this.name = name;
        this.superTypes = superTypes;
        this.printingSuperTypes = JSON.parse(JSON.stringify(superTypes));
        this.properties = properties;
    }
    toString() {
        const interfaceNode = new generator_node_1.CompositeGeneratorNode();
        const superTypes = this.printingSuperTypes.length > 0 ? distictAndSorted(this.printingSuperTypes) : ['AstNode'];
        interfaceNode.contents.push(`export interface ${this.name} extends ${superTypes.join(', ')} {`, generator_node_1.NL);
        const propertiesNode = new generator_node_1.IndentNode();
        if (this.containerTypes.length > 0) {
            propertiesNode.contents.push(`readonly $container: ${distictAndSorted(this.containerTypes).join(' | ')};`, generator_node_1.NL);
        }
        for (const property of distictAndSorted(this.properties, (a, b) => a.name.localeCompare(b.name))) {
            const optional = property.optional && property.typeAlternatives.some(e => e.reference) && !property.typeAlternatives.some(e => e.array) ? '?' : '';
            const type = propertyTypeArrayToString(property.typeAlternatives);
            propertiesNode.contents.push(`${property.name}${optional}: ${type}`, generator_node_1.NL);
        }
        interfaceNode.contents.push(propertiesNode, '}', generator_node_1.NL);
        pushReflectionInfo(this.name, interfaceNode);
        return (0, node_processor_1.processGeneratorNode)(interfaceNode);
    }
}
exports.InterfaceType = InterfaceType;
function collectAllAstResources(grammars, documents, visited = new Set(), astResources = { parserRules: new Set(), datatypeRules: new Set(), interfaces: new Set(), types: new Set() }) {
    for (const grammar of grammars) {
        const doc = (0, ast_util_1.getDocument)(grammar);
        if (visited.has(doc.uri)) {
            continue;
        }
        visited.add(doc.uri);
        for (const rule of grammar.rules) {
            if ((0, ast_1.isParserRule)(rule) && !rule.fragment) {
                if ((0, grammar_util_1.isDataTypeRule)(rule)) {
                    astResources.datatypeRules.add(rule);
                }
                else {
                    astResources.parserRules.add(rule);
                }
            }
        }
        grammar.interfaces.forEach(e => astResources.interfaces.add(e));
        grammar.types.forEach(e => astResources.types.add(e));
        if (documents) {
            const importedGrammars = grammar.imports.map(e => (0, grammar_util_1.resolveImport)(documents, e));
            collectAllAstResources(importedGrammars, documents, visited, astResources);
        }
    }
    return astResources;
}
exports.collectAllAstResources = collectAllAstResources;
function propertyTypeArrayToString(alternatives) {
    return distictAndSorted(alternatives.map(typePropertyToString)).join(' | ');
}
exports.propertyTypeArrayToString = propertyTypeArrayToString;
function distictAndSorted(list, compareFn) {
    return Array.from(new Set(list)).sort(compareFn);
}
exports.distictAndSorted = distictAndSorted;
function typePropertyToString(propertyType) {
    let res = distictAndSorted(propertyType.types).join(' | ');
    res = propertyType.reference ? `Reference<${res}>` : res;
    res = propertyType.array ? `Array<${res}>` : res;
    return res;
}
exports.typePropertyToString = typePropertyToString;
function pushReflectionInfo(name, node) {
    node.contents.push(generator_node_1.NL, `export const ${name} = '${name}';`, generator_node_1.NL, generator_node_1.NL);
    node.contents.push(`export function is${name}(item: unknown): item is ${name} {`, generator_node_1.NL);
    const methodBody = new generator_node_1.IndentNode();
    methodBody.contents.push(`return reflection.isInstance(item, ${name});`, generator_node_1.NL);
    node.contents.push(methodBody, '}', generator_node_1.NL);
}
//# sourceMappingURL=types-util.js.map